/*
题目出处：NOIP2008 提高组 传纸条
题目：
小渊和小轩是好朋友也是同班同学，他们在一起总有谈不完的话题。
一次素质拓展活动中，班上同学安排做成一个m行n列的矩阵，而小渊
和小轩被安排在矩阵对角线的两端，因此，他们就无法直接交谈了。
幸运的是，他们可以通过传纸条来进行交流。纸条要经由许多同学传
到对方手里，小渊坐在矩阵的左上角，坐标(1,1)，小轩坐在矩阵的
右下角，坐标(m,n)。从小渊传到小轩的纸条只可以向下或者向右传
递，从小轩传给小渊的纸条只可以向上或者向左传递。在活动进行中，
小渊希望给小轩传递一张纸条，同时希望小轩给他回复。班里每个同学
都可以帮他们传递，但只会帮他们一次，也就是说如果此人在小渊递给
小轩纸条的时候帮忙，那么在小轩递给小渊的时候就不会再帮忙。反之
亦然。还有一件事情需要注意，全班每个同学愿意帮忙的好感度有高有
低（注意：小渊和小轩的好心程度没有定义，输入时用0表示），可以
用一个0-100的自然数来表示，数越大表示越好心。小渊和小轩希望尽
可能找好心程度高的同学来帮忙传纸条，即找到来回两条传递路径，
使得这两条路径上同学的好心程度只和最大。现在，请你帮助小渊和
小轩找到这样的两条路径。
*/
#include<cstdio>
#include<iostream>
#include<cstring>
using namespace std;
const int mx = 55;
int a[mx][mx],dp[mx][mx][mx][mx];
int max(int a,int b){
    return a > b ? a : b;
}
int main(){
int m,n;
memset(dp,0,sizeof(dp));
scanf("%d%d",&m,&n);
for(int i=1;i<=m;i++)
    for(int j=1;j<=n;j++)
        scanf("%d",&a[i][j]);
dp[2][1][1][1]=a[2][1];
dp[1][1][1][2]=a[1][2];
for(int i=1;i<=m;i++)
    for(int j=1;j<=n;j++)
        for(int k=1;k<=m;k++)
            for(int l=1;l<=n;l++){
                //if(i==k||j==l)continue;
                if((i+1)!=k&&j!=l)dp[i+1][j][k][l]=max(dp[i+1][j][k][l],dp[i][j][k][l]+a[i+1][j]);
                if(i!=k&&(j+1)!=l)dp[i][j+1][k][l]=max(dp[i][j+1][k][l],dp[i][j][k][l]+a[i][j+1]);
                if(i!=(k+1)&&j!=l)dp[i][j][k+1][l]=max(dp[i][j][k+1][l],dp[i][j][k][l]+a[k+1][l]);
                if(i!=k&&j!=(l+1)) dp[i][j][k][l+1]=max(dp[i][j][k][l+1],dp[i][j][k][l]+a[k][l+1]);
            }
printf("%d\n",dp[m][n-1][m-1][n]);
return 0;
}
